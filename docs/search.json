[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Workshop em R",
    "section": "",
    "text": "Bem-Vindo!!\nEste é um pequeno manual escrito com o objetivo de ajudar você com seus primeiros passos dentro da linguagem R. Ele foi escrito para que seja um acompanhamento aos conceitos apresentados ao longo do workshop, embora você possa voltar a ele quando quiser para revisar algum conceito.\nA divisão do manual foi pensada a partir da experiência do autor na sua própria jornada de aprendizado do R. Dado que aprender uma nova linguagem apresenta desafios, e uma curva de aprendizado íngrime, espero que a organização proposta possa reduzir o seu custo de entrada nessa fantástica ferramenta de análise de dados!",
    "crumbs": [
      "Bem-Vindo!!"
    ]
  },
  {
    "objectID": "capitulos/01.instalacao.html",
    "href": "capitulos/01.instalacao.html",
    "title": "1  Instalações Necessárias",
    "section": "",
    "text": "Nessa primeira parte vamos fazer a instalação dos programas necessários para rodar o R e fazer as análises que serão vistas nas demais sessões desse material. Serão dois programas necessários: o primeiro é o próprio programa R, que embora não seja utilizado diretamente, será preciso tê-lo instalado; o segundo é o RStudio, que representa uma interface na qual vamos executar os códigos que o R vai interpretar.\nPara fazer a instalação de cada um desses programas podemos entrar no site da Posit para sermos direcionados ao download de cada um dos programas necessários, como indica a Figura 1.1.\n\n\n\nFigura 1.1: Baixando os softwares necessários\n\n\n\n\n\n\nPrecisamos começar por baixar o próprio programa R, clicando no botão Download and Install R, Figura 1.1, que vai nos direcionar para o site onde é disponibilizado o R para fazermos o seu download, Figura 1.2, onde vamos precisar escolher baixar o R de acordo com o sistema operacioal compatível com nosso computador.\n\n\n\nFigura 1.2: Site para baixar o R\n\n\n\n\n\n\nUma vez escolhido o sistema operacional, seremos direcionados para uma nova página, Figura 1.3, onde precisamos clicar em install R for the first time, fazendo com que na próxima página possamos pedir para baixar o arquivo executável em nosso computador, Figura 1.4. Devemos executar esse arquivo e seguir as recomendações padrões sugeridas por ele, e então o R estará instalado em nossa máquina.\n\n\n\nFigura 1.3: Baixando o arquivo executável\n\n\n\n\n\n\n\n\n\nFigura 1.4: Baixando o arquivo executável (cont)\n\n\n\n\n\n\nO último passo é baixarmos o RStudio, onde como indica a Figura 1.1, precisamos clicar em Download RStudio Desktop for Windowns, na qual baixará um arquivo executável para nosso computador, e onde vamos apenas seguir as orientações padrões sugeridas por ele.\nSe tudo ocorreu como esperado, deveremos ter um novo ícone do RStudio em nosso computador, no qual ao clicarmos uma tela muito próxima a da que está sendo mostrada na Figura 1.5 deverá estar sendo mostrada. Será nela que vamos inserir funções responsáveis por manipular banco de dados, fazendo com que possamos realizar análises desses dados, algo que faremos nas próximas sessões.\n\n\n\nFigura 1.5: Janela do RStudio",
    "crumbs": [
      "PARTE 1",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Instalações Necessárias</span>"
    ]
  },
  {
    "objectID": "capitulos/02.nocoes_iniciais.html",
    "href": "capitulos/02.nocoes_iniciais.html",
    "title": "2  Noções Iniciais",
    "section": "",
    "text": "2.1 Criando um script\nNo RStudio, todo comando que precisamos executar é feito via Console, por exemplo, se quisermos fazer uma simples soma, 1 + 1, basta digitar esse comando na aba Console e clicarmos em Enter, como mostrado na Figura 2.1.\nEsse, contudo, não será o método que vamos utilizar, dado que para deixar nossas análises mais claras e simples, faremos uso de um script! Um script nada mais é do que um arquivo onde vamos escrever e salvar todas as nossas linhas de códigos em qualquer análise que fizermos dentro do RStudio.\nPara criarmos um script podemos seguir um dos seguintes métodos:\nQuando criamos um Script, ele automaticamente adiciona um novo painel ao RStudio, Figura 2.4.\nApós termos nosso script criado, podemos realizar todos os nossos cálculos dentro do R escrevendo nesse script as linhas de código que serão executadas no Console, Figura 2.5. Lembrando que para que o nosso código seja executado quando ele está no script temos duas opções: ou clicamos no ícone Run dentro do nosso script; podemos utilizar um atalho CTRL + Enter1.\nAgora que já temos nosso script carregado, podemos então avançar na próxima sessão aprendendo como podemos criar uma variável, como fazer operações com essas variáveis e quais os tipos de variáveis mais comuns.",
    "crumbs": [
      "PARTE 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Noções Iniciais</span>"
    ]
  },
  {
    "objectID": "capitulos/02.nocoes_iniciais.html#criando-um-script",
    "href": "capitulos/02.nocoes_iniciais.html#criando-um-script",
    "title": "2  Noções Iniciais",
    "section": "",
    "text": "Figura 2.1: Executando nosso primeiro código no R\n\n\n\n\n\n\n\n\n\nNa barra de navegação principal siga File &gt; New File &gt; R Script , como mostra a Figura 2.2.\n\n\n\nFigura 2.2: Criando nosso Script\n\n\n\n\n\n\nClicando no seguinte ícone mostrado na Figura 2.3:\n\n\n\nFigura 2.3: Segunda maneira de criarmos nosso script\n\n\n\n\n\n\nUtilizando um atalho no teclado: Ctrl + Shift + N\n\n\n\n\n\nFigura 2.4: Nosso primeiro script dentro do RStudio\n\n\n\n\n\n\n\n1 Esse atalho para executar um código que está em nosso script é um dos atalhos que vale a penas gravar!!\n\n\nFigura 2.5: Executando o código em nosso script",
    "crumbs": [
      "PARTE 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Noções Iniciais</span>"
    ]
  },
  {
    "objectID": "capitulos/02.nocoes_iniciais.html#primeiras-variáveis-e-seus-tipos",
    "href": "capitulos/02.nocoes_iniciais.html#primeiras-variáveis-e-seus-tipos",
    "title": "2  Noções Iniciais",
    "section": "2.2 Primeiras variáveis e seus tipos",
    "text": "2.2 Primeiras variáveis e seus tipos\nDando sequência ao nosso processo de conhecer o R, vamos agora definir variáveis e realizar operações com elas para irmos nos acostumando com a linguagem utilizada pelo R. Na sequência, vamos criar essas variáveis sempre em nosso script, embora aqui vamos estar mostrando apenas o código que produz essa variável.\nNossa primeira variável2 no R, que vamos chamar de a, será apenas um número e vamos criar por meio da seguinte linha de código:\n2 Tecnicamente, qualquer variável que é criada no R é chamada de um objeto. Contudo, para uma facilidade de explicação, variável e objeto serão tratados como sinônimos. Quando necessário fazer a distinção entre variável e objeto, isso será feito no texto.\na &lt;- 3\n\nPoderíamos ler o seguinte código como: estamos associando o número 3 a variável a, ou, estamos criando a variável a e a ela será associada ao número 3. Algumas coisas importantes de observarmos na variável anteriormente construída:\n\nO nome é totalmente arbitrário, poderia ter sido qualquer outro que quisessemos ter escolhido3;\nPrecisamos utilizar &lt;- para criarmos variáveis no R4.\n\n3 O bom senso aqui deve se impor!! Algumas regras deveriam ser seguidas: prefira nomes curtos e claros, que descrevam bem seus dados; se os nomes forem compostos, utilize ” _ “, exemplo, meus_dados, e não meus dados; não escolha nomes com letras maiúsculas ou acentos; nunca use números no início do nome, exemplo, 1dados, embora dados_1 é permitido.4 Existe um segundo atalho que você deveria decorar, o que criar o símbolo &lt;-: Alt -Essa variável que foi criada ficará disponível no Environment do RStudio, podendo ser acessada ao digitarmos seu nome no script ou Console:\n\na\n\n[1] 3\n\n\nPodemos a partir de uma variável realizar cálculos, como por exemplo, as quatro operações básicas: +, -, / (divisão) e ^ (multiplicação):\n\n# somando um valor qualquer a nossa variável\na + 2\n# multiplicando um valor qualquer pela nossa variável\na^2\n# subtraindo um valor qualquer de nossa variável\na - 2\n# dividindo um valor qualquer de nossa variável\na/2\n\nNo código acima, também fizemos uso de comentários para deixar nosso código mais intuitivo por meio dos símbolos #. Qualquer coisa que vier depois desse símbolo não será executado pelo R, por isso podemos ir comentando nosso script a medida que fomos executando os códigos, algo que facilita muito nosso processo de aprendizagem.\nAlém das operações básicas, podemos utilizar funções sobre nossa variável, como por exemplo, calcular o logarítimo log():\n\n# calculando o logarítimo de nossa variável\nlog(a)\n\n[1] 1.098612\n\n\nVeremos ainda algumas outras funções, por hora, vamos deixar as coisas mais interessantes ao modificarmos nossa variável a. Até o momento, essa variável tem apenas um elemento, mas podemos transformar a variável a em um pequeno vetor por meio de outra função que vamos utilizar muito, c(), vejamos um exemplo no código seguinte:\n\n# aumentando o número de elementos de nosso vetor\na &lt;- c(2,4,6,8)\n\nAlgumas coisas quando temos um vetor construído por meio da função c():\n\nA variável criada com ele transformou nossa variável original em um vetor com mais elementos, logo, nosso vetor original não mais existe;5\nTodas as funções anteriormente ainda podem ser aplicadas6, com a única diferença que agora teremos as operações aplicadas elemento a elemento, como na álgebra matemática de vetores.\n\n5 Isso é algo que você precisará tomar muito cuidado, pois se salvar uma base de dados sobre outra, a original será perdida! Evite fazer isso colocando nomes diferentes nas variáveis e bancos de dados que for criar dentro do R.6 Faça o teste!Podemos criar outro vetor e fazermos operações com nosso vetor original para comprovar isso. Por exemplo, no código abaixo vamos criar um vetor chamado dados_2 e somar com nossa variável a.\n\ndados_2 &lt;- c(20,14,8,1.4)\n\n# fazendo a soma dos dois vetores\ndados_2 + a\n\n[1] 22.0 18.0 14.0  9.4\n\n# aplicando uma função ao vetor e depois somando\nlog(dados_2) + a\n\n[1] 4.995732 6.639057 8.079442 8.336472\n\n# calculando a média por meio da função mean()\nmean(dados_2)\n\n[1] 10.85\n\n\nUma outra observação que vai nos ajudar ao longo do aprendizado, no R, qualquer número com casas decimais deverá ser separado por “.”, não por vírgula como estamos acostumados no Brasil. A vírgula, dentro de um vetor como dados_2 e a, serve apenas para separar os elementos desse vetor.\nNossos vetores até aqui foram claramente numéricos, pois foi possível realizar operações matemáticas com eles. Contudo, vamos observar que diversas variáveis podem ser não numéricas, e no R todas serão definidas entre aspas em um vetor, como no código a seguir.\n\nnomes &lt;- c(\"Felipe\", \"Tatiane\", \"Paula\", \"Carlos\")\n\nSe tentarmos fazer operações entre um vetor numérico e uma função matemática anterior, ou operações entre vetores que deveriam ter dois vetores numéricos, teremos naturalmente um erro.\n\ndados_2 + nomes\n\nUm cuidado extra, dado que estamos começando, é observar que não podemos misturar em um mesmo vetor (variável) valores de diferentes tipos, numéricos e não numéricos, pois isso fará com que o vetor seja transformado em valores não numéricos.\n\n# esse vetor está com problemas\nnao_sou_numero &lt;- c(\"1\", \"2\", \"3\")\n\n# esse também\nvai_dar_erro &lt;- c(1, 2, \"Três\")\n\nEmbora simples, vetores são um primeiro passo para entendermos o processo de manipulação de dados dentro da linguagem R. Na sequência, vamos importar nosso primeiro banco de dados, que nada mais será do que um conjunto de variáveis (vetores) na sua forma retangular, mas que cada uma deverá possuir um único tipo, ou seja, ou a variável deverá ser numérica ou então não numérica.\nAntes, porém, vamos precisar ter acesso a uma função para conseguir ler esses dados e importar para dentro do R, e isso será feito por meio de um pacote chamado tidyverse que precisará ser instalado e carregado, nossos próximos passos.",
    "crumbs": [
      "PARTE 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Noções Iniciais</span>"
    ]
  },
  {
    "objectID": "capitulos/02.nocoes_iniciais.html#sec-instalando-e-carregando-um-pacote-no-r",
    "href": "capitulos/02.nocoes_iniciais.html#sec-instalando-e-carregando-um-pacote-no-r",
    "title": "2  Noções Iniciais",
    "section": "2.3 Instalando e Carregando um Pacote no R",
    "text": "2.3 Instalando e Carregando um Pacote no R\nMuitas das melhores funções não fazem parte do núcleo do R, não estando portanto, disponíveis no momento que instalamos o programa. Isso é feito de maneira proposital, dado que cada função atende a um proprósito específico, e instalar previamente todas essas funções apenas faria com que o programa se tornasse pesado e grande para ser baixado, e de pouca utilidade se não precisassemos da maioria dessas funções.\nPara contornar esse tipo de problemas é que o R se utiliza dos chamados pacotes que são estruturas que contém algumas funções que realizam tarefas específicas. Esses pacotes são então baixados e carregados no R para que possamos utilizar tais funções, algo muito mais lógico se nosso objetivo é utilizar funções que realizam tarefas específicas dentro de nosso trabalho com os dados. Por exemplo, existem pacotes que são disponibilizados para instalar um tipo específico de extensão de arquivo, para realizar um tipo de análise estatística, construír um tipo específico de visualização, entre tantas outras tarefas. A ideia básica é então instalar e carregar em nossa máquina, apenas as ferramentas que serão de fato utilizadas em nossa análise, não precisando carregar material desnecessário que não será utilizado.\n\n2.3.1 Instalando pacotes: install.packages()\nPara fazermos uso desses pacotes7, precisamos primeiro fazer sua instalação, o que é claro, será feito com o uso de um função!! A função utilizada para instalar os pacotes no R é chamada install.packages(), sendo que o argumento que usamos dentro dela é o nomes do pacote a ser instalado, sempre entre aspas, como por exemplo, install.packages(\"pacote\").\n7 Para termos uma noção da quantidade de pacotes disponíveis, enquanto escrevo existem cerca de 21132 pacotes para serem utilizados no R. Para saber quantos pacotes existem no momento em que lê esse material, você pode acessar o repositório de pacotes do R, chamado cran, pelo seguinte endereço: https://cran.r-project.org/web/packages/Vamos na sequência fazer a instalação de um dos pacotes que mais vamos utilizar para trabalhar com dados, chamado tidyverse. Para isso, podemos escrever a seguinte linha de código em nosso script:\n\n# instalando meu primeiro pacote\ninstall.packages(\"tidyverse\")\n\nO processo de instalação de qualquer pacote vai sempre produzir algumas menssagens no Console do R, , Figura 2.6, indicando por exemplo, as etapas que o pacote está realizando para poder operar sem erro, ou se está realizando a instalação de pacotes adicionais que ele precisa. No geral é um processo pouco complexo, sendo difícil apresentar algum problema nessa etapa.\n\n\n\nFigura 2.6: Instalando nosso primeiro pacote\n\n\n\n\n\n\nAlternativamente, principalmente nas primeiras vezes que você estiver utilizando o R, pode ser possível instalar os pacotes indo na aba “Packages”, Figura 2.7, clicando em Install, que faz aparecer uma nova janela na tela do RStudio onde podemos indicar o pacote a ser instalado.\n\n\n\nFigura 2.7: Instalando um pacote via aba “Packages”\n\n\n\n\n\n\nOutro ponto que precisamos já aprender ao utilizarmos pacotes dentro do R é que eles precisam ser instalados uma única vez, por isso, uma dica muito importante é não manter no script o passo que fizemos anteriormente, ou seja, install.packages(\"tidyverse\"), porque caso nos descuidemos podemos pedir para ele ser instalado novamente.\nUma alternativa é sempre que instalamos algum pacote, logo após ele ter sido instalado, comentarmos a linha onde aparece o código, como mostrado abaixo. Assim, o R sempre vai considerar aquela linha de código como um comentário e vai ignorar.\n\n# instalando meu primeiro pacote\n# install.packages(\"tidyverse\")\n\n\n\n2.3.2 Carregando pacotes: library()\nUma vez que o pacote tenha sido baixado e instalado, as funções que ele possui são instaladas em nossas máquina, contudo, isso não implica que já podemos utilizar essas funções. Para poder utilizar as funções de um pacote, precisamos sempre carregar esse pacote, e isso é feito com mais uma função, chamada library(nome_do_pacote). Como podemos ver na próxima linha de código e Figura 2.8, podemos carregar o pacote tidyverse da seguinte maneira:\n\n# carregando nosso pacote tidyverse\nlibrary(tidyverse)\n\n\n\n\nFigura 2.8: Carregando nosso pacote\n\n\n\n\n\n\nAo carregarmos nosso pacote, também é comum aparecerem mensagens na tela do Console, Figura 2.8, mas isso não é motivo para pânico, na maioria dos casos é apenas para indicar possíveis conflitos entre funções de pacotes diferentes, mas que em nada vão prejudicar nossas análises, por isso, podemos desconsiderar por enquanto essas mensagens.\nImportante destacar que para utilizar uma função de um pacote é sempre preciso carregar ele, ou seja, ao fecharmos o R em nosso computador, quando abrirmos novamente será preciso carregar esse pacote para que as funções estejam disponíveis, embora não mais seja preciso instalar o pacote. Além disso, não esqueça que não precisamos utilizar as aspas quando carregamos um pacote!!\nAgora com nosso pacote tidyverse, instalado e carregado, podemos utilizar uma de suas funções para importarmos nossa primeira base de dados para o R, o que será feito na próxima sessão.\n\n\n2.3.3 Exemplo prático: carregando nossas primeiras bases de dados\nAqui, como uma maneira de já irmos nos acostumando com o uso de funções dentro do R, vamos utilizar a função presente no tidyverse chamada read_csv() para importarmos a seguinte base de dados que está nesse link8.\n8 Essa base de dados faz parte do projeto Tidytuesday, que semanalmente oferece uma temática em forma de dados para que a comunidade de usuários do R possa treinar suas habilidade e/ou produza algum tipo de visualização.Para importarmos a base basta indicarmos a sua URL dentro da função read_csv(), entre aspas, e indicarmos qual nome gostaríamos de dar para essa base de dado dentro do R, no caso vamos escolher o nome filmes, como indicado na linha de código abaixo e mostrado na Figura 2.9.\n\n# baixando nossa primeira base de dados\nfilmes &lt;- read_csv(\"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2018/2018-10-23/movie_profit.csv\")\n\n\n\n\nFigura 2.9: Carregando nossa primeira base de dados\n\n\n\n\n\n\nImportante notar algumas coisa a respeito do que fizemos:\n\nO objeto criado, filmes, ficará sempre visível na aba Environment e poderia ter sido qualquer nome, mas lembre de utilizar nomes pequenos e nunca utilizar espaços em branco9;\nSempre utilize o &lt;- para criar um objeto que desejamos manter na memória do R e ser possível acessar ao longo da análise, caso contrário, ele somente será mostrado uma única vez na tela do Console;\nO nome da URL ficou entre parêntes! Depois, quando importarmos um arquivo de nosso próprio computador, o diretório também deverá ser especificado entre aspas.\nNão se preocupe com as mensagens que são produzidas no Console do RStudio, pois elas não indicam que algo de errado aconteceu, apenas algumas informações sobre como a função read_csv() decidiu formatar as colunas de nossa base de dados. Caso algo tivesse dado errado, provavelmente a base não teria sido salva no Environment!\n\n9 Prefira dar nomes como: dados, meus_dados ou d.1. Nunca deixe espaço em um nome composto nem use um numeral na frente do nomes escolhido: meus dados ou 1dados!Agora que temos nossa primeira base de dados, vamos na sequência verificar como podemos acessar suas variáveis e valores.",
    "crumbs": [
      "PARTE 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Noções Iniciais</span>"
    ]
  },
  {
    "objectID": "capitulos/02.nocoes_iniciais.html#sec-conhecendo-nosso-banco-de-dados",
    "href": "capitulos/02.nocoes_iniciais.html#sec-conhecendo-nosso-banco-de-dados",
    "title": "2  Noções Iniciais",
    "section": "2.4 Conhecendo nosso Banco de Dados",
    "text": "2.4 Conhecendo nosso Banco de Dados\nAqui vamos aprender a retirar informações iniciais de nossa base de dados, começando por acessar a mesma10. Para isso, podemos fazer de duas maneiras:\n10 Nosso objetivo aqui é meramente o de conhecer a nossa base de dados depois de ela ter sido importada. Uma análise dos dados no sentido mais completa será feita depois que tivermos conhecimento de outras funções presente no pacote tidyverse.\nao clicar com o mouse no ícone que aparece junto com a base dos dados na aba Environment, como mostrado na Figura 2.10, fazendo com que uma nova aba com os dados surja ao lado de nosso script Figura 2.11;\n\n\n\nFigura 2.10: Acessando nossos dados\n\n\n\n\n\n\nou podemos utilizar linhas de códigos, como por exemplo, digitando o próprio nome da base em nosso script ou utilizando a função view(filmes)., que também fará com que os dados surjam em uma nova aba do RStudio próxima ao script Figura 2.11.\n\n\n# verificando nossa base de dado\nview(filmes)\n\n\n\n\nFigura 2.11: Nossos dados em uma nova aba\n\n\n\n\n\n\nÉ possível ainda ter a opção de destacar os dados em uma nova janela no PC. Para isso, basta clicarmos no ícone mostrado na Figura 2.11 fazendo com que os dados possam ser verificados em nova janela, Figura 2.12.\n\n\n\nFigura 2.12: Mostrando os dados em uma nova janela\n\n\n\n\n\n\nAlgumas funções podem ser úteis no processo de conhecer nossa base de dados. Uma delas é a função summary() que permite que tenhamos um pequeno estatística de nossos dados. Podemos executar ela pelo seguinte código:\n\nsummary(filmes)\n\n      ...1      release_date          movie           production_budget  \n Min.   :   1   Length:3401        Length:3401        Min.   :   250000  \n 1st Qu.: 851   Class :character   Class :character   1st Qu.:  9000000  \n Median :1701   Mode  :character   Mode  :character   Median : 20000000  \n Mean   :1701                                         Mean   : 33284743  \n 3rd Qu.:2551                                         3rd Qu.: 45000000  \n Max.   :3401                                         Max.   :175000000  \n domestic_gross      worldwide_gross     distributor        mpaa_rating       \n Min.   :        0   Min.   :0.000e+00   Length:3401        Length:3401       \n 1st Qu.:  6118683   1st Qu.:1.062e+07   Class :character   Class :character  \n Median : 25533818   Median :4.016e+07   Mode  :character   Mode  :character  \n Mean   : 45421793   Mean   :9.412e+07                                        \n 3rd Qu.: 60323786   3rd Qu.:1.176e+08                                        \n Max.   :474544677   Max.   :1.305e+09                                        \n    genre          \n Length:3401       \n Class :character  \n Mode  :character  \n                   \n                   \n                   \n\n\nEssa função é uma das muitas que já são internas ao R, ou seja, são instaladas no momento que baixamos o programa e instalamos em nossa máquina, não exigindo pacotes. Como pode ser percebido, ela indica as cinco estatísticas resumo para alguma de nossas variáveis, somente as variáveis de tipo numerico, tais como o mínimo e o máximo. No caso das variáveis não numericas, não é mostrado esse tipo de informação!\nOutra função útil é a função names(), que apenas descreve o nome das colunas (variáveis) de nosso banco de dados. Ela pode ser útil em casos onde tenhamos esquecido o nome de alguma das variáveis11, cuja execução pode ser feita pelo seguinte código:\n11 Importante já destacar aqui que temos uma coluna chamada 1, que na verdade não possui informação alguma. Na próxima sessão veremos como nos livrar de variáveis como essa por meio de outras funções.\nnames(filmes)\n\n[1] \"...1\"              \"release_date\"      \"movie\"            \n[4] \"production_budget\" \"domestic_gross\"    \"worldwide_gross\"  \n[7] \"distributor\"       \"mpaa_rating\"       \"genre\"            \n\n\nOutra função muito útil, que nos mostra qual o tipo de dado foi associado a cada variável é a função glimpse(), função essa que é carregada do pacote tidyverse. Sua execução pode ser feita pelo seguinte comando e pela Figura 2.13.\n\nglimpse(filmes)\n\n\n\n\nFigura 2.13: Tipos das variáveis\n\n\n\n\n\n\nNesse processo de aprender a linguagem, basta para nós identificarmos que as variáveis que são não numéricas vão estar com o tipo definido como &lt;chr&gt;, referência a character, enquanto que as numéricas vão estar com o tipo &lt;dbl&gt;, fazendo a referência a double. Outro sinal de que uma variável é não numérica é seus valores sempre estarão representados entre aspas. Além disso, a função glimpse() permite ainda ter a informação sobre o tamanho da base de dados, como o número de linhas e o número de colunas.",
    "crumbs": [
      "PARTE 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Noções Iniciais</span>"
    ]
  },
  {
    "objectID": "capitulos/02.nocoes_iniciais.html#salvando-nosso-script",
    "href": "capitulos/02.nocoes_iniciais.html#salvando-nosso-script",
    "title": "2  Noções Iniciais",
    "section": "2.5 Salvando nosso script",
    "text": "2.5 Salvando nosso script\nApós termos feito nossa análises, em nosso caso ter carregado um pacote e feito a importação de uma base de dados, o próximo passo é darmos segurança ao nosso trabalho e salvarmos o script que criamos e que colocamos nossos primeiros códigos. Para isso, podemos fazer como mostrado na Figura 2.14.\n\n\n\nFigura 2.14: Salvando um script em nosso computador\n\n\n\n\n\n\nDepois que fecharmos o script, podemos novamente abrir por meio dos passos descritos na Figura 2.15. Dessa maneira nosso material será novamente aberto para que possamos acrescentar mais linhas de códigos e sempre que terminarmos de adicionar algo útil, podemos novamente salvar ao clicar no ícone descrito na Figura 2.14.\n\n\n\nFigura 2.15: Abrindo nosso script\n\n\n\n\n\n\nAgora que sabemos carregar um pacote, uma base de dados, salvar nosso script e abri-lo novamente, já podemos partir para voos mais altos e começarmos a modificar essa nossa base de dados para criarmos algum tipo de análise. Essa será nosso foco na segunda parte desse material, onde vamos mais a fundo conhecer as muitas funções que estão presentes no pacote tidyverse.",
    "crumbs": [
      "PARTE 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Noções Iniciais</span>"
    ]
  },
  {
    "objectID": "capitulos/03.colunas_linhas.html",
    "href": "capitulos/03.colunas_linhas.html",
    "title": "3  Manipulando Colunas e Linhas",
    "section": "",
    "text": "3.1 Instruções Iniciais\nCada uma das próximas sessões será destinada a ensinar uma das funções presente no pacote tidyverse, começando pela função select(), que veremos, servirá para selecionar determinadas colunas da base de dados.\nCom o básico que vimos sobre o R até aqui, já é preciso saber que para usar uma função de um pacote qualquer precisamos sempre de duas coisas: primeiro, carregar previamente esse pacote para termos acesso as funções; segundo, caso ainda não tenhamos utilizado o pacote, precisamos instalar o pacote em nossa máquina1. Portanto, o que precisamos fazer será apenas carregar esse pacote novamente, como indicado na linha de código abaixo por meio da função library()2:\n# carregando o pacote tidyverse\nlibrary(tidyverse)\nAlém do pacote que carregamos, carregaremos novamente a base de dados que vamos utilizar para esse estudo como indicado na linha de código a seguir3:\n# baixando nossa primeira base de dados\nfilmes &lt;- read_csv(\"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2018/2018-10-23/movie_profit.csv\")\nCom nosso pacote e banco de dados carregado, podemos agora aprender a selecionar as colunas por meio da função select().",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulando Colunas e Linhas</span>"
    ]
  },
  {
    "objectID": "capitulos/03.colunas_linhas.html#instruções-iniciais",
    "href": "capitulos/03.colunas_linhas.html#instruções-iniciais",
    "title": "3  Manipulando Colunas e Linhas",
    "section": "",
    "text": "1 Como visto na Seção 2.3.1, somente precisamos instalar nosso pacote uma única vez.2 Não é necessário colocar o nome do pacote entre aspas quando estamos carregando o mesmo! Caso tenha dúvidas ainda sobre essa parte, volte e revise os pontos apresentados sobre instalação e carregamento de pacotes descritos na Seção 2.3.\n\n3 Não será aqui indicado como podemos acessar a base de dados que carregamos, pois isso já foi trabalhado na Seção 2.4. Caso precise, volte e revise esse conteúdo!",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulando Colunas e Linhas</span>"
    ]
  },
  {
    "objectID": "capitulos/03.colunas_linhas.html#função-select-e-o-uso-do-operador-pipe--",
    "href": "capitulos/03.colunas_linhas.html#função-select-e-o-uso-do-operador-pipe--",
    "title": "3  Manipulando Colunas e Linhas",
    "section": "3.2 Função select() e o uso do Operador Pipe - |>",
    "text": "3.2 Função select() e o uso do Operador Pipe - |&gt;\nEm muito casos práticos, quando estamos começando a trabalhar com nossa base de dados, embora ao fazermos o processo de importação tenhamos a disposição todas as colunas (variáveis) desse banco de dados, nem todas elas serão de nosso interesse. Por isso, aprender a selecionar apenas as variáveis que vamos utilizar é algo desejável, já que quanto menor o banco de dados, ou seja, com menos variáveis desnecessárias ela continver, menor será a exigência computacional de nossa máquina e mais rápida será nossa análise.\n\n3.2.1 Selecionando algumas colunas 1\nPara selecionarmos as colunas de um banco de dados, que contém ao todo 9 linhas, podemos fazer uso da função select() cujos argumentos inseridos nela vão especificar quais colunas gostaríamos de trabalhar de nossa base de dados, ou qual gostaríamos de excluir.\nDigamos que gostaríamos apenas de selecionar as seguintes variáveis da base filmes: movies, genre, release_date, mpaa_rating. Poderíamos fazer isso utilizando a seguinte linha de código cujo resultado será mostrado na tela do Console do R4:\n4 Não estaremos mostrando os resultados dos demais códigos que forem executados nessa parte apenas por uma questão de comodidade, mas lembre que todos vão aparecer na tela do Console do RStudio!\n# selecionando algumas colunas de nossa base de dados\nfilmes |&gt; \n  select(movie, genre, release_date, mpaa_rating)\n\n# A tibble: 3,401 × 4\n   movie                               genre     release_date mpaa_rating\n   &lt;chr&gt;                               &lt;chr&gt;     &lt;chr&gt;        &lt;chr&gt;      \n 1 Evan Almighty                       Comedy    6/22/2007    PG         \n 2 Waterworld                          Action    7/28/1995    PG-13      \n 3 King Arthur: Legend of the Sword    Adventure 5/12/2017    PG-13      \n 4 47 Ronin                            Action    12/25/2013   PG-13      \n 5 Jurassic World: Fallen Kingdom      Action    6/22/2018    PG-13      \n 6 Guardians of the Galaxy             Action    8/1/2014     PG-13      \n 7 Iron Man 2                          Action    5/7/2010     PG-13      \n 8 Captain America: The Winter Soldier Action    4/4/2014     PG-13      \n 9 Dawn of the Planet of the Apes      Adventure 7/11/2014    PG-13      \n10 The Polar Express                   Adventure 11/10/2004   G          \n# ℹ 3,391 more rows\n\n\nAlgumas coisas precisam ser ditas aqui antes de aprofundarmos mais na função select(), talvez sendo a primera delas referente ao próprio código utilizado, em especial ao símbolo que apareceu: |&gt;5.\n5 Existe um atalho para que possamos criar esse símbolo sem ter que digitar: Ctrl + Shift + M!!Esse símbolo, chamado pipe, é uma maneira de dizermos de onde devem vir os insumos de nossa função. Por exemplo, na função select() queremos selecionar as variáveis movie, genre, release_date, mpaa_rating, que foram descritas dentro dela. De onde virão essas variáveis? Virão de nossa base de dados chamada filmes que foi escrita à esquerda do pipe.\nLogo, o pipe pode ser entendido como: aplique a função que está à direita do pipe, utilizando os insumos que estão à esquerda do pipe! No caso do exemplo acima, selecione as variáveis indicadas na função select(), que foi escrita à direita do pipe, que virão da base de dados chamada filmes, que foi escrita à esquerda do pipe.\nOutra consideração sobre o código descrito acima é a de que ele foi escrito em linhas separadas, mas isso não é uma regra, apenas uma maneira de deixarmos nosso código mais organizado, ele poderia ser sido escrito como no código abaixo, embora a recomendação para que os códigos sejam mais claros, é que cada função deverá vir em sua própria linha, algo que vamos observar ao longo do uso de mais funções.\n\n# selecionando algumas colunas de nossa base de dados\nfilmes |&gt; select(movie, genre, release_date, mpaa_rating)\n\nVoltando a função select(), é importante observar que a ordem na qual as colunas vão aparecer será a mesma que foi indicada dentro da função. Veja o resultado do seguinte código que seleciona as mesmas variáveis anteriores, apenas mudando a ordem na qual são indicadas dentro da função select():\n\n# modificando a ordem das variáveis em nosso banco de dados\nfilmes |&gt; \n  select(genre, mpaa_rating, movie, release_date)\n\n\n\n3.2.2 Salvando nossa seleção de colunas\nUm coisa muito importante, no código anterior, as variáveis que foram selecionadas de nosso banco de dados filmes, não foram salvas no R, ou seja, elas foram apenas executadas uma única vez no Console. Para que elas fiquem salvas para serem utilizadas em outras funções, precisamos criar um objeto, uma segunda base de dados, que será evidentemente menor do que a original que foi importada. Para fazer isso, vamos novamente utilizar aquele operados &lt;-, como indicado na próxima linha de códigos:\n\n# salvando nossas quatro variáveis em um novo objeto\nfilmes2 &lt;- \n  filmes |&gt; \n  select(genre, mpaa_rating, movie, release_date)\n\nOs novos dados, chamados de filmes2, foram agora salvos e estão disponíveis dentro do Environmet do R para serem utilizados6.\n6 Utilize a função view(filmes2) para inspecionar esse objeto criado.7 Quando digo que os dados foram salvas, quero dizer que eles estão disponíveis para serem utilizados enquanto o R estiver aberto. Veremos em momento oportuno que é possível também salvar nossos dados de maneira física, ou seja, no próprio computador em um fomato como o .xlsx. Porém, para nossos própositos, isso ainda não é necessário!Uma observação também precisa ser feita aqui: no geral, nunca salve um objeto com o nome de outro que já exista. Por exemplo, caso tivesse criado a nova base de dados com o mesmo nome da original, você teria perdido as informações contidas na base de dados filmes. Observe que ao indicar outro nome, as duas bases permanecem disponíveis, filmes, a que foi primero baixada com todas as variáveis, e a segunda, filmes2, com apenas algumas colunas da base originalmente baixada7.\n\n\n3.2.3 Selecionando algumas colunas 2\nOutra maneira de selecionarmos quais vairáveis de um banco de dados queremos é indicando com o sinal de - quais delas deverão ser descartadas. Por exemplo, digamos que em nossas análises futuras não precisamos das variáveis release_date e distributor, bastaria dentro da função select() indicar essas duas variáveis com o sinal de menos na frente, com mostrado na linha de código seguinte.\n\n# eliminando as duas colunas indicadas abaixo\nfilmes |&gt;  \n  select(-release_date, -distributor)\n\nAinda poderíamos ter escrito o código acima fazendo o uso da função c(), sendo uma maneira alternativa ao código acima:\n\n# eliminando as duas colunas indicadas abaixo\nfilmes |&gt;  \n  select(-c(release_date, distributor))\n\nNo codigo acima, o resultado é o mesmo, apenas estamos dizendo que não queremos todas as colunas descritas dentro de c(). Isso é muito útil quando temos varias colunas a serem eliminadas e queremos economizar no uso do -.\n\n\n3.2.4 Selecionando algumas colunas 3\nPor fim, podemos ainda utilizar as posições das variáveis em nosso banco de dados, indicadas por um valor numérico, dentro da função select(), tanto para manter variáveis, quanto para excluir variáveis.\nDigamos que queiramos manter as mesmas variáveis anteriormente trabalhadas, movie, genre, release_date e mpaa_rating. Essas variáveis ocupam as seguintes colunas da base de dados filmes: 2, 3, 8 e 9. Se indicarmos esses números na função select(), teremos o mesmo resultado obtido anteriormente:\n\n# selecionando por meio de posições das variáveis na base de dados\nfilmes |&gt; \n  select(2,3,8,9)\n\nEvidentemente, a ordem em que o valor numérico for indicado na função select() vai definir como as variáveis serão posicionadas.\nNessa maneira de selecionarmos variáveis, será util utilizar o simbolo : para indicar que queremos selecionar intervalos de colunas, por exemplo, se quisermos selecionar as quatro primeiras variáveis do nosso banco de dados, ao inves de dentro da função select() indicamor 1,2,3,4, podemos indicar 1:4, como mostra o código abaixo:\n\n# selecionando por meio de posições das variáveis na base de dados\nfilmes |&gt; \n  select(1:4)\n\nA maneira numérica ainda é util quando queremos elimar uma variável que não tem uma informação útil, e que apresente um nome problemático, como é a primeira coluna de nossos dados. Podemos facilmente eliminarmos tal variável indicando -1 dentro da função select():\n\n# eliminando variáveis por meio da sua posição numérica\nfilmes |&gt; \n  select(-1)\n\nNesse último caso, poderíamos ter salvo o resultado utilizando o próprio nome original filmes, dado que a seleção não implicou perda de informação útil de nosso banco de dados. Se fossemos fazer isso, poderíamos utilizar o código abaixo8. Mas lembre-se, tome cuidado ao fazer isso e certifique-se de que não está perdendo informação útil!!\n8 Em outras partes desse material veremos como se livrar de variáveis inúteis no próprio momento que fazemos a importação dos dados, algo que vamos aprender quando estudarmos os argumentos possíveis da função read_csv2().\n# filmes será o 'novo' banco de dados\nfilmes &lt;- \n  filmes |&gt; # criado a partir do select aplicado em filmes\n  select(-1)",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulando Colunas e Linhas</span>"
    ]
  },
  {
    "objectID": "capitulos/03.colunas_linhas.html#modificando-o-nome-das-colunas",
    "href": "capitulos/03.colunas_linhas.html#modificando-o-nome-das-colunas",
    "title": "3  Manipulando Colunas e Linhas",
    "section": "3.3 Modificando o nome das colunas",
    "text": "3.3 Modificando o nome das colunas\nÉ possível modificarmos o nome das colunas de nosso banco de dados de duas maneiras, ou melhor, com o uso de duas funções do nosso pacote tidyverse. Vamos começar pela função rename() cujo nome já é bastante intuitivo.\nContudo, antes de proceguir vale mencionar as regras para um bom nome de uma variável:\n\nTodos os nomes em letra minúscula, curtos e descritivos;\nNunca deixar espaços em branco em um nome, separe os nomes compostos com _;\nNunca utilize acentos ou letras típicas do português, como ç. Prefira escrever com c!\n\nNa função rename() vamos indicar sempre o novo nome que queremos e o nome original da variável que será modificado. Digamos que nosso objetivo seja o de modificar o nome da variável release_date para data_de_lancamento, para isso bastaria aplicar o seguinte código:\n\nfilmes |&gt; \n  rename(data_de_lancamento = release_date)\n\nÉ possível também modificar o nome de uma variável por meio de sua posição, como mostra o próximo exemplo:\n\nfilmes |&gt; \n  rename(\n    data_de_lancamento = release_date, \n    arrecadacao_mundial = 6    ) |&gt; \n  select(data_de_lancamento, arrecadacao_mundial)\n\nA outra maneira de modificarmos o nome da variável é quando utilizamos a função select(). Para isso, basta no momento de selecionarmos as colunas de nosso interesse já fazer a modificação do nome da variável. Vejamos o exemplo:\n\nfilmes |&gt; \n  select(filme = movie, arrecadacao_mundial = 6)\n\nQualquer uma das maneiras fará com que o nome de uma coluna de nossa base de dados seja modificado9.\n9 Veremos ser possível modificar o nome da variável no momento em que fazemos a importação do dado, por meio de algum argumento na função read_csv().",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulando Colunas e Linhas</span>"
    ]
  },
  {
    "objectID": "capitulos/03.colunas_linhas.html#pedindo-ajuda-para-o-chatgpt",
    "href": "capitulos/03.colunas_linhas.html#pedindo-ajuda-para-o-chatgpt",
    "title": "3  Manipulando Colunas e Linhas",
    "section": "3.4 Pedindo ajuda para o chatGPT",
    "text": "3.4 Pedindo ajuda para o chatGPT\nEssa parte vai ser destinada para que possamos aprender a utilizar o chatGPT para construir nossos códigos, Isso vai ajudar a termos um tutor que vá nos ajudando na tarefa de dominar a linguagem do R, de seus pacotes e nos ajudando a ficar mais confiantes em nosso avanço, reduzindo o custo de entrado no mundo do R, e de qualquer linguagem de programação.\nPara que o ChatGPT possa nos ajudar, o que precisamos fazer é basicamente dar uma descrição bastante detalhada do que estamos precisando fazer no R. Por exemplo, podemos utilizar a função select() e rename(), que já aprendemos, e pedir para ele nos ajudar como se estivessemos ainda aprendendo. Por exemplo, poderíamos indicar o seguinte prompt mostrado por meio da Figura 3.1:\n\n\n\nFigura 3.1: Pedindo ajuda ao ChatGPT\n\n\n\n\n\n\nOutra ajuda que poderíamos procurar obter poderia ser para nos ajudar com o conceito do operador pipe |&gt;, o que poderíamos pedir para que ele utilizasse o contexto da conversa anterior, na qual pedimos para ajudar com select(), Figura 3.2.\n\n\n\nFigura 3.2: Aprendendo sobre o pipe no ChatGPT\n\n\n\n\n\n\nUtilizar o recurso do ChatGPT é um recurso valioso que podemos ter nos dias atuais, principalmente quando estamos começando na liguagem R, na qual ficarmos travados em algum ponto pode ser frustante, e infelizmente, um motivo de desistência para muitos iniciantes na linguagem.",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulando Colunas e Linhas</span>"
    ]
  },
  {
    "objectID": "capitulos/03.colunas_linhas.html#função-arrange-slice-e-suas-derivações",
    "href": "capitulos/03.colunas_linhas.html#função-arrange-slice-e-suas-derivações",
    "title": "3  Manipulando Colunas e Linhas",
    "section": "3.5 Função arrange(), slice() e suas derivações",
    "text": "3.5 Função arrange(), slice() e suas derivações\nÉ possível dentro das funções do pacote tidyverse também fazer a seleção de linhas de nossa base de dados e não apenas colunas. Para isso, podemos utilizar a função slice() com argumentos que vão determinar o numero de linhas que deve ser retornado. Além disso, podemos facilmente fazer a classificação da nossa base de dados a partir de uma variável, tanto em ordem crescente quanto em ordem decrescente com o uso da função arrange().\n\n3.5.1 Selecionando linhas 1\nA maneira que selecionamos as linhas de um base de dado é um processo bastante simples. Por exemplo, indicando as linhas de 1:10 dentro da função slice(), vai nos retonar as dez primeiras linhas do nosso banco de dados, como mostra o código abaixo.\n\n# selecionando as dez primeiras linhas\nfilmes |&gt; \n  slice(1:10)\n\nComo é possível perceber, a base de dados filmes agora mostra apenas as dez primeiras linhas, com todas as suas variáveis. Caso nosso código tivesse sido indicado como slice(10), teríamos apenas como resposta a décima linha do nosso banco de dados, como indicado no código abaixo.\n\n# selecionando as dez primeiras linhas\nfilmes |&gt; \n  slice(10)\n\nDa mesma forma que select() pode ser utilizado com um sinal de menos indicando quais colunas queremos excluir, a função slice() vai excluir todas as linhas que forem indicadas com sinal de -, como mostra o código abaixo pedindo para eliminar a linha 10:\n\n# selecionando as dez primeiras linhas\nfilmes |&gt; \n  slice(-10)\n\nPodemos ainda selecionar linhas que não estejam interligadas, para isso, podemos utilizar a seguinte syntaxe:\n\n# selecionando as dez primeiras linhas\nfilmes |&gt; \n  slice(1:5, 10, 30:40)\n\n\n\n3.5.2 Ordenando os dados\nEm nossa base de dados filmes, temos ao todo 3401 e dentro das variáveis temos uma que indica as receitas mundiais do respectivo filme chamada worldwide_gross. Digamos que nosso objetivo seja o de ordenar aqueles filmes que possuem a maior receita, para isso, podemos utilizar a função arrange() como mostrado no código abaixo:\n\nfilmes |&gt; \n  arrange(worldwide_gross)\n\nUma coisa estranha aconteceu, como resultado, a base de dados agora mostra o filme do Aquamen como o primeiro, mas ele não possui receita mundial, apenas zero! O ‘problema’ com o código acima é que ele por default classifica uma variável em ordem crescente, ou seja, do menor valor para o maior. Para que os dados sejam classificados em ordem decrescente, do maior para o menor valor, precisamos aplicar a função desc() dentro da função arrange(), como mostra nosso próximo código:\n\nfilmes |&gt; \n  arrange(desc(worldwide_gross))\n\nAgora podemos perceber que o valor retornado foi o correto. Inclusive podemos para melhorar nossa visibilidade no Console do R, aplicarmos um pouco daquilo que já aprendemos. Por exemplo, se só nos interessa saber quais são os filmes com maior bilheteria no mundo, vamos selecionar apenas as variáveis que precisamos, como mostrado na sequência:\n\n# quero utilizar a base de dados filmes nas próximas etapas\nfilmes |&gt; \n  # sendo que quero selecionar as seguintes colunas:\n  select(movie, worldwide_gross) |&gt; \n  # das quais quero que sejam classificadas em ordem decrescente\n  arrange(desc(worldwide_gross))\n\nUm resultado bem mais limpo de ver10! Vale mencionar no código anterior as etapas que foram feitas, sendo que todas elas indicam uma operação sendo feita à direita do pipe, por exemplo, na primeira linha precisamos indicar de onde virão os dados, no caso, filmes; na segunda, indicamos que queremos selecionar as colunas movie e worldwide, que vieram dos dados que estão à esquerda do pipe; e por último, queremos ordenar/classificar nossos dados a partir da variável worldwide_gross, cujos dados nessa etapa já foram reduzidos para apenas duas colunas devido ao pipe anterior que foi feito.\n10 Uma dica importante que dou é você fazer uso de comentários nas linhas de código, como as que foram feitas nesse exemplo. Isso vai ajudar você a aprender mais rápido quando voltar a utilizar o mesmo script ou deixar seu trabalho mais organizado, dados que você pode ir indicando as etapas que está fazendo.Poderíamos na etapa anterior pedir para ficarmos com apenas as cinco maiores bilheterias mundias, para isso, poderíamos utilizar a função slice(1:5).\n\n# quero utilizar a base de dados filmes nas próximas etapas\nfilmes |&gt; \n  # sendo que quero selecionar as seguintes colunas:\n  select(movie, worldwide_gross) |&gt; \n  # das quais quero que sejam classificadas em ordem decrescente\n  arrange(desc(worldwide_gross)) |&gt; \n  # selecionado as cinco maiores bilheterias\n  slice(1:5)\n\nÉ possível também fazer a classificação de variáveis nominais, cuja classificação será feita por ordem alfabética. Digamos que queremos classificar os filmes segundo seu gênero, poderíamos aplicar o seguinte código:\n\nfilmes |&gt; \n  select(movie, genre) |&gt; \n  arrange(genre)\n\nNo código executado, o padrão para variáveis qualitativas também é o de mostrar do menor valor para o maior quando não indicado a função auxiliar desc(), no caso mostrando da letra A até a letra Z. Aqui vale ressaltar novamente que os ordenamentos feitos não alteram a base de dados original. Essas alterações só ficarão salvas se criarmos um novo objeto.\n\n\n3.5.3 Selecionando linhas 2\nNas etapas onde ordenamos os dados com a função arrange(), em um dos casos nos pedimos para retornar as cinco primeiras linhas que correspondiam aos filmes com as maiores bilheterias. Esse é um procedimento bastante comum que podemos reduzir etapas se fizermos uso de variantes da função slice(), no caso a função slice_max() e slice_min()11. Por exemplo, podemos pedir para que seja retornado o maior valor de bilheteria mundial com o seguinte código:\n11 Ainda vão existir outras variações da função slice() que podem ser utilizadas, cada uma com algum proposito específico.\nfilmes |&gt; \n  slice_max(order_by = worldwide_gross)\n\nO resultado será o retorno de uma linha, já que estamos utilizando a função slice(), mas que retorna a linha que contém o maior valor da variável worldwide_gross, por isso aqui slice_max().\nImportante destacar que dentro da função slice_max(), para fazermos o ordenamento utilizamos o termos order_by = worldwide_gross. Como já sabemos, worldwide_gross é o nome de uma das colunas de nosso banco de dados, mas o termo order_by ganha um nome especial, pois ele é um parâmetro da função slice_max(), no presente caso, aquele que precisa ser indicado para a função slice_max() saber sobre qual coluna ela deve buscar o valor máximo!\nQuase todas as funções vão possuir parâmetros, a própria função slice_max() possui mais parâmetros, como por exemplo o parâmetro n que é onde nós indicamos o número de linhas que devem ser retornadas, como mostra o próximo exemplo12:\n12 Neste exemplo, a maneira como organizei as linhas de código foi no sentido de deixar em cada linha separada um argumento da função slice_max(). Isso não é uma obrigação, mas deixa o código mais limpo, principalmente se precisamos utilizar muitos argumentos. Além disso, a dica segue muito útil, comente as etapas que estiver construindo no seu código!\nfilmes |&gt; \n  slice_max(\n    # indicando a variável que a função deve classificar\n    order_by = worldwide_gross, \n    # o numero de linhas que ela deve retornar\n    n = 5)\n\nComo podemos saber o numero de parâmetros de uma função? O mais indicado, embora um pouco mais avançado seria procurar a documentação da função onde existe uma descrição da função que estamos utilizando construida por que criou o pacote. Podemos pedir ajuda por exemplo indicando o seguinte código:\n\n?slice_max\n\nO código vai abrir a janela chamada Help, mostrando a documentação da função, com os argumentos possíveis como mostra a Figura 3.3.\n\n\n\nFigura 3.3: Ajuda para identificar parâmetros de uma função\n\n\n\n\n\n\nAlém do código ?slice_max, poderíamos ter entrado diretamente na aba Help e digitado na busca slice_max, ou o nome de qualquer outra função que queremos conhecer melhor. Importante destacar que não devemos utilizar os parênteses () quando queremos pedir ajuda!\nOutra maneira útil de pedir ajuda como vimos é com o ChatGPT. Por exemplo, se criarmos um prompt como mostrado na Figura 3.4, poderemos ter uma excelente ajuda para sabermos quais são os parâmetros que a função slice_max() possui, bem como qualquer outra que gostaríamos.\n\n\n\nFigura 3.4: Pedindo ao ChatGPT para descrever os parâmetros de slice_max()\n\n\n\n\n\n\nSe nossa necessidade é o de obter os menores valores para uma variável na base de dados, podemos então utilizar a função slice_min(), cujos parâmetros são os mesmos da função slice_max(). No exemplo mostrado no código abaixo, vamos pedir para retornar os filmes que tiveram o menor faturamento mundial:\n\nfilmes |&gt; \n  slice_min(\n    order_by = worldwide_gross, \n    n = 10\n  )\n\nOutra possibilidade no uso das funções acima é o de apenas indicar os parâmetros, sem a indicação de order_by ou n. Contudo, isso pode ser fonte de erro e dúvidas em quem está começando a utilizar essas funções, embora em pessoas mais avançadas na linguagem o comum é que não se observe essa descrição mais detalhada. Sendo assim, os códigos seriam executados se tivessem sido escritos como:\n\nfilmes |&gt; \n  slice_max(worldwide_gross, 10)\n\nfilmes |&gt; \n  slice_min(worldwide_gross, 10)\n\nA única advertência é a de que os valores dos parâmetros sejam colocados na sua ordem certa, a ordem na qual a função slice_ exige. Se invertessemos, colocando antes o 10, teríamos um erro! Além disso, existem parâmetros que serão obrigatórios e outros que são opcionais, por exemplo, order_by será sempre um parâmetro obrigatório, dado que sem ele a função slice_ não saberá o que retornar.\nPara concluir, nessa parte aprendemos como selecionar linhas de nossa base de dados com a função slice(), ou com suas variações que nos permitiram maior flexibilização na seleção das linhas a partir de critérios. Contudo, veremos que podemos utilizar a função filter() para também selecionar linhas, mas com um grau de sofisticação muito maior em termos de busca que podemos aplicar.",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulando Colunas e Linhas</span>"
    ]
  },
  {
    "objectID": "capitulos/03.colunas_linhas.html#função-filter",
    "href": "capitulos/03.colunas_linhas.html#função-filter",
    "title": "3  Manipulando Colunas e Linhas",
    "section": "3.6 Função filter()",
    "text": "3.6 Função filter()\nComeçamos aqui o uso da função filter() cujo resultado será também eliminar linhas a partir de critérios escolhidos por nós. Nessa parte vamos fazer um intenso uso de critérios lógicos que permitirão que possamos selecionar linhas com critérios de colunas diferentes.\nVamos começar com um exemplo simples, ainda aplicado somente a uma das colunas, pedindo para que sejam retornados todos os filmes com classificação igual a R de nossa variável mpaa_rating13, como mostra o próximo código:\n13 mpaa_rating é a variável que indica a classificação do filme criada pela Motion Picture Association de acordo com faixas, onde R, por exemplo, indica filmes que possuem algum tipo de restrição ao acesso.\nfilmes |&gt; \n  filter(mpaa_rating == \"R\")\n\nComo podemos perceber, o nosso filtro retornou um total de 1514 linhas, que correspondem ao total de filmes que atenderam ao critério buscado dentro da função filter().\nO critério passado dentro da função filter() é bastante intuitivo, ela nos diz para que a coluna que contém a variável mpaa_rating retorne todos os critérios/valores iguais a R, de nossa base de dados filmes, que como sabemos, está à esquerda do operador pipe.\nDuas observações aqui são importantes: 1. Quando queremos selecionar algo que seja exatamente igual a um critério, devemos utilizar ==. Caso a busca for feita com apenas =, teremos uma mensagem de erro!! Segundo, todos os critérios que forem valores de uma variável qualitativa, devem vir entre aspas, como foi \"R\", caso contrário também teremos um erro em nossa execução!!\nOs operadores possíveis são:\n\n==, que como vimos retornar algo que seja exatamente igual ao critério pedido;\n&gt;, que retorna algo que seja estritamente maior do que o critério pedido;\n&gt;=, que retorna algo que seja maior ou igual ao critério pedido;\n&lt;, que retorna algo que seja estritamente menor do que o critério pedido;\n&lt;=, que retorna algo que seja menor ou igual ao critério pedido;\n!=, que retorna algo que não seja igual ao critério pedido;\n\nAlguns exemplos podem ser vistos nos códigos abaixo:\n\n# selecionando filmes com faturamento mundial maior do que 500 milhões\nfilmes |&gt; \n  filter(worldwide_gross &gt; 500000000)\n\n# selecionando todos os filmes que não sejam iguais a R\nfilmes |&gt; \n  filter(mpaa_rating != \"R\")\n\n# selecionando filmes com orçamento abaixo ou igual a 1 milhão\nfilmes |&gt; \n  filter(production_budget &lt;= 1000000) \n\n\n3.6.1 Filtrando linhas com o uso do &\nPodemos utilizar duas variáveis para especificar critérios de busca, como por exemplo, filmes com classificação indicativa R e cujo orçamento de produção foi maior ou igual do que 200 milhões, como mostra o seguinte código:\n\nfilmes |&gt; \n  filter(mpaa_rating == \"R\" & production_budget &gt;= 200000000)\n\nComo podemos ver pelo resultado, na busca não tivemos nenhum resultado encontrado, isso porque nenhum filme com a classificação R teve orçamento de produção tão alto, agora se refazermos o critério para buscar filmes com orçamento de 150 milhões, podemos ver que o resultado é uma lista com 7 filmes.\n\nfilmes |&gt; \n  filter(mpaa_rating == \"R\" & production_budget &gt;= 150000000) |&gt; \n  select(movie, mpaa_rating, production_budget)\n\nPoderíamos ainda buscar por filmes que são de comédia e cuja classificação foi PG como no código abaixo:\n\nfilmes |&gt; \n  filter(mpaa_rating == \"PG\" & genre == \"Comedy\")\n\nEm todos os códigos acima que buscaram comparar duas colunas diferentes, fizemos o uso do termos &. É ele o responsável por comparar as duas colunas e retornar apenas aquelas que atendem aos dois critérios pedidos.\n\n\n3.6.2 Filtrando valores com between()\nNa próxima situação vamos buscar comparar os filmes que tiveram um orçamento entre dois valores, por exemplo, entre 5 e 10 milhões. Poderíamos ter feito isso com base no que já aprendemos aqui como será mostrado no código a seguir:\n\nfilmes |&gt; \n  filter(production_budget &gt;= 5000000 & production_budget &lt;= 10000000)\n\nEsse tipo de filtro pode ser feito com uma função auxiliar chamada between() muito interessante, que reduz a duplicação em nosso código. Vejamos sua aplicação:\n\nfilmes |&gt; \n  filter(\n    between(production_budget, 5000000, 10000000)\n    )\n\nA função between() vai possuir três argumentos que devem ser fornecidos, o primeiro deles é a variável na qual queremos obter o intervalo de valores, depois o limite inferior de nosso intervalo e posteriormente o limite superior. Lembrando que nessa função, ela sempre vai incluir os intervalos indicados!\n\n\n3.6.3 Filtrando valores com | e %in%\nOutra situação muito comum de quem utiliza a função filter() é o de filtrar por mais de um valor. Digamos que nosso objetivo seja o de selecionar apenas os filmes que foram distribuídos pelas seguintes empresas: Warner Bros., Sony Pictures e MGM. Poderíamos aplicar o seguinte filtro sobre a variável distributor:\n\nfilmes |&gt; \n  filter(distributor == \"MGM\" | distributor == \"Lionsgate\" | distributor == \"Universal\")\n\nNo código acima a barra vertical | indica que queremos que o filtro aplicado sobre a vairável distributor retorne MGM ou Lionsgate ou Universal. Mesmo se uma das condições não é atendida, ele vai retornar as demais quando utilizamos o |, diferente do & na qual as condições precisam ser todas verdadeiras. Contudo, existe uma maneira mais simples de obter os resultados acima, para isso podemos utilizar a seguinte expressão:\n\nfilmes |&gt; \n  filter(distributor %in% c(\"MGM\", \"Lionsgate\", \"Universal\") )\n\nCom o uso do %in% basta especificarmos os valores que queremos filtrar para uma variável dentro do nosso vetor construído com c(), deixando o código muito mais simples e limpo.\nNo próximo capítulo vamos trabalhar com mais funções do pacote tidyverse em nosso processo de aprendizado de como manipular bases de dados com o R. Contudo, antes de irmos para o próximo capítulo, deixo a mensagem de que pode ser muito útil no processo de entendimento das funções estudadas aqui, e de seu aprofundamento, contar com a ajuda do ChatGPT, seja para nos explicar os argumentos das funções, seja para nos fornecer exemplos. Se for utilizar essa ferramenta fantástica, procure deixar o mais claro possível o que está tentando realizar no R e que não conseguiu.",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Manipulando Colunas e Linhas</span>"
    ]
  },
  {
    "objectID": "capitulos/04.resumindo_dados.html",
    "href": "capitulos/04.resumindo_dados.html",
    "title": "4  Construindo Medidas Resumo",
    "section": "",
    "text": "4.1 Função count()\nA partir de nossa base filmes1 podemos utilizar a variável count() para contar os valores de algumas de nossas variáveis qualitativas, por exemplo, genre e mpaa_rating e distributor. Vejamos a sintaxe da função a partir de um exemplo mostrado abaixo:\nfilmes |&gt; \n  count(genre)\nPodemos perceber que a resposta é uma tabela com a frequência absoluta do número de ocorrências de cada um dos valores de nossa variável. Se adicionarmos um argumento na função acima poderemos ter esses valores ordenados, como indicado no próximo código:\nfilmes |&gt; \n  count(genre, sort = TRUE)\nO argumento sort = TRUE fez o mesmo papel de nossa função arrange(desc()), o que sem dúvida é algo útil porque nos poupa de aplicarmos mais uma linha de código. A função ainda possui outro argumento, name, na qual permite que mudemos o nome da coluna que foi criada com os valores de frequência.\nfilmes |&gt; \n  count(genre, sort = T, name = \"total\")\nVejamos mais alguns exemplos aplicados ao longo das outras variáveis:\n# aplicando a função count na variável mpaa_rating\nfilmes |&gt; \n  count(mpaa_rating, sort = T)\n\n# contando o número de observações da variável distriuidor\nfilmes |&gt; \n  count(distributor, sort = T)",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Construindo Medidas Resumo</span>"
    ]
  },
  {
    "objectID": "capitulos/04.resumindo_dados.html#função-count",
    "href": "capitulos/04.resumindo_dados.html#função-count",
    "title": "4  Construindo Medidas Resumo",
    "section": "",
    "text": "1 Lembre-se que você precisa carregar os dados por meio de uma função que pertence ao pacote tidyverse.",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Construindo Medidas Resumo</span>"
    ]
  },
  {
    "objectID": "capitulos/04.resumindo_dados.html#sec-valores-na",
    "href": "capitulos/04.resumindo_dados.html#sec-valores-na",
    "title": "4  Construindo Medidas Resumo",
    "section": "4.2 Valores NA",
    "text": "4.2 Valores NA\nNos códigos anteriores, na primeira contagem feita, onde pedimos para contar as categorias de indicativos etários, apareceu um valor chamado NA. Esse já é um momento adequado para trabalharmos esse conceito, dado que esse ‘valor’ vai aparecer muito em nossas análises, simplesmente indicando um valor ausente para a variável considerada. No contexto de nossos dados, apenas nos diz que alguns filmes não contém essa informação para a variável, ou seja, não possuem qual a indicação etária sugerida.\nComo tratamos dados ausêntes? No geral a resposta seria desconsiderar, mas a resposta vai depender da análise sendo feita, sendo muito pessoal a decisão do que fazer. Independente disso, podemos lidar com valores ausêntes a partir de duas funções: filter() e drop_na().\n\n4.2.1 Filtrando os valores NA\nUma maneira muito útil de lidar com variáveis NA é utilizando a função filter(), onde podemos identificar os valores NA e decidirmos se mantemos em nossa base de dados ou eliminamos. Para identificar os valores NA em uma coluna de nossa base aplicarmos a função is.na() dentro de nossa função filter(), como mostrado no código abaixo:\n\nfilmes |&gt; \n  filter(is.na(mpaa_rating))\n\nO resultado é o retorno apenas dos filmes que não possuem classificação indicativa, que são ao todo 137 filmes. O termo is.na() utilizado faz com que o nosso filtro busque apenas as ocorrência lógicas verdadeiras, ou seja, que fazem com que os valores da variável procurada tenham valores ausentes.\nPoderíamos agora pensar em excluir esses filmes, se os mesmos não fossem importantes ou se isso não produzisse algum tipo de prejuízo em nossa análise. Para isso, basta modificarmos um pouco o nosso código acima, como indicamos na sequência.\n\nfilmes |&gt; \n  filter(!is.na(mpaa_rating))\n\nO resultado é que agora nossa base não possui mais valores ausêntes na variável mpaa_rating, podemos confirmar isso aplicando novamente a função count() para verificar os valores dessa variável.\n\nfilmes |&gt; \n  filter(!is.na(mpaa_rating)) |&gt; \n  count(mpaa_rating, sort = T)\n\nO termo ! já foi apresentado quando estudamos alguns dos operadores que poderíamos utilizar dentro da função filter(). Naquela situação, tinhamos utilizado em conjunto com =, ou seja, !=, para indicar que gostaríamos de filtrar tudo que não fosse igual a tal critério. Aqui ele está fazendo a mesma coisa, só que agora ele vai indicar que não queremos valores ausentes, !is.na().\n\n\n4.2.2 Função drop_na()\nA outra função que podemos utilizar para tratar desse problema é a função drop_na(). Ela pode ser utilizada tanto em uma variável específica, como mpaa_rating, ou deixada sem argumento, que fará com que qualquer valor ausente seja eliminado, independente da variável.\n\n# eliminando valores ausentes da variável mpaa_rating\nfilmes |&gt; \n  drop_na(mpaa_rating)\n\n# eliminando qualquer valor ausente\nfilmes |&gt; \n  drop_na()\n\nA diferença é que no primeiro caso a base de dados resultante ficou com 3264 linhas, enquanto que na última, os dados foram reduzidos para 3230 linhas.\nCabe destacar que é sempre útil aplicar a função summary() em nossos dados, para identificarmos quais variáveis possuem valores NA, entre outras estatísticas. É uma maneira simples de conhecermos nossa base de dados, como destacado na.",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Construindo Medidas Resumo</span>"
    ]
  },
  {
    "objectID": "capitulos/04.resumindo_dados.html#função-distinct",
    "href": "capitulos/04.resumindo_dados.html#função-distinct",
    "title": "4  Construindo Medidas Resumo",
    "section": "4.3 Função distinct()",
    "text": "4.3 Função distinct()\nUma função também muito útil é a função distinct(), muito próxima da ideia da função count(), mas que permite verificar quais são os valores distintos dentro de uma variável. Vejamos sua aplicação nas variáveis anteriormente trabalhadas.\n\n# obtendo os valores distintos dos ratings\nfilmes |&gt; \n  distinct(mpaa_rating)\n\n# obtendo o número de distribuidores de filmes\nfilmes |&gt; \n  distinct(distributor)\n\n# quais os generos dos filmes \nfilmes |&gt; \n  distinct(genre)\n\nEssa função é muito interessante para conhecermos melhor nossa base de dados, inclusive para identificar quais os valores poderão ser utilizados em filtros. Em nosso próximo passo para analisar os dados, faremos uso da função summarise() para construir medidas resumo das variáveis quantitativas.",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Construindo Medidas Resumo</span>"
    ]
  },
  {
    "objectID": "capitulos/04.resumindo_dados.html#função-summarise",
    "href": "capitulos/04.resumindo_dados.html#função-summarise",
    "title": "4  Construindo Medidas Resumo",
    "section": "4.4 Função summarise()",
    "text": "4.4 Função summarise()\nPara que possamos entender como utilizar a função summarise() vamos partir da ideia de que nosso objetivo fosse o de descobrir o total arrecadado pelos filmes com sua bilheteria internacinal. Para fazer isso, vamos utilizar o próximo código:\n\nfilmes |&gt; \n  summarise(\n    arrecadacao = sum(worldwide_gross)\n  )\n\nNo comando anterior foi preciso adicionar algumas coisas a mais do que apenas a função summarise(), vamos então entender melhor cada uma delas:\n\nQuando utilizamos a função summarise() será importante darmos um nome para nossa medida a ser calculada, como foi feito ao indicarmos que estamos calculando a arrecadacao2;\nO valor da arrecadacao foi calculado pela função auxiliar sum() aplicada sobre a variável de interesse, no caso worldwide_gross.\n\n2 Lembre-se de não utilizar acentos e outras letras características do português!!3 Essas funções auxiliares não são instaladas pelo pacote tidyverse porque elas já são funcões que são disponibilizadas pelo próprio R no momento da instalação do programa.Assim, sempre para utilizar a função summarise() vamos precisar também de alguma função auxiliar, como foi o caso de sum(), mas poderia ter sido mean(), median(), etc…3.\nNossa base de dados não possui muitas opções para realizarmos cálculos, dado que apenas três variáveis quantitativas estão presentes: production_budget, domestic_gross e worldwide_gross. Contudo, vamos ver mais alguns exemplos, começando pelo cálculo da média arrecadada.\n\nfilmes |&gt; \n  summarise(\n    # arrecadação média em vendas domésticas\n    receita_media_domestica = mean(domestic_gross), \n    # arrecadação média em vendas internacionais\n    receita_media_internacional = mean(worldwide_gross)\n  )\n\nNa linha anterior é possível perceber que podemos realizar mais de uma cálculo dentro da função summarise() bastando para isso que separemos com vírgula cada um dos cálculos. Vejamos mais alguns exemplos:\n\nfilmes |&gt; \n  summarise(\n    r_total_domestica = sum(domestic_gross), \n    arrecadacao_maxima = max(domestic_gross), \n    media_arrecadacao_domestica = mean(domestic_gross), \n    desvio_padrao_domestica = sd(domestic_gross)\n  )\n\nEmbora nenhuma de nossas variáveis numéricas possui valores NA, precisaríamos ter o cuidado no caso delas estarem presentes, isso porque, quando existem valores NA o resultado de qualquer cálculo com a função summarise() será NA. Para evitar isso podemos dentro da função summarise() utilizar o argumento adicional na.rm = TRUE.\n\nfilmes |&gt; \n  summarise(\n    r_total_domestica = sum(domestic_gross, na.rm = TRUE)\n  )\n\nAo utilizar esse argumento adicional dentro de cada uma das funções auxiliares que entram no cálculo da summarise(), essa função vai automaticamente desconsiderar esses valores quando ela indentificar um valor NA.\nInfelizmente, para o propósito de exemplo, a base de dados filmes não possui nenhum valor ausente para indicarmos aqui, contudo, já sabemos como o ChatGPT pode ser utilizado como ferramenta de estudos. Então, como um exercício, você pode pedir para que ele explique como os valores NA podem atrapalhar seu cálculo quando estamos utilizando a função summarise(), pedindo incluise para que ele construa um exemplo simples para você reproduzir no R.",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Construindo Medidas Resumo</span>"
    ]
  },
  {
    "objectID": "capitulos/04.resumindo_dados.html#agrupando-dados-com-a-função-group_by",
    "href": "capitulos/04.resumindo_dados.html#agrupando-dados-com-a-função-group_by",
    "title": "4  Construindo Medidas Resumo",
    "section": "4.5 Agrupando dados com a função group_by()",
    "text": "4.5 Agrupando dados com a função group_by()\nOs cálculos anterior realizados resumiram toda uma coluna de dados, ou seja, em um dos exemplos calculamos qual foi a receita mundial de todos os filmes de nossa amostra. Contudo, em determinadas situações, seria interessante ter esse cálculo agrupado para determinados valores, como por exemplo, qual foi a arrecadação por tipo de gênero.\nPara que isso seja possível é que precisamos antes agrupar os dados, e isso será feito com a função group_by(), como é mostrado no próximo código.\n\nfilmes |&gt; \n  group_by(genre) |&gt; \n  summarise(\n    receita = sum(worldwide_gross)\n  )\n\nNo código anterior, antes de utilizar a função summarise() para calcular a soma, simplesmente aplicamos a função group_by() com o nome da variável cujos valores serão agrupados, no caso genre. Poderíamos utilizar essa mesma lógica para outras variáveis que gostaríamos de aplicar o agrupamento, como por exemplo, separando por classificação indicativa, como mostrado na sequência.\n\nfilmes |&gt; \n  group_by(mpaa_rating) |&gt; \n  summarise(\n    receita = sum(worldwide_gross)\n  )\n\nEm nosso exemplo anterior é possível perceber que muitos filmes não possuem a classificação, o que implicou que no resultado o valor NA aparecesse como um de nossos valores, caso esse valor não fosse necessário, como visto anteriormente na Seção 4.2, poderíamos ter eliminado ele em uma etapa antes.\nO processo de calcular valores para determinados grupos dos nossos dados é tão comum que até mesmo a função summarise() possui um argumento adicional que permite indicar qual será o grupo. Esse agrupamento é chamado de .by e podemos ver sua aplicação por meio do código abaixo que mostra um código muito mais limpo e resumido:\n\nfilmes |&gt; \n  summarise(\n    receita = sum(worldwide_gross), \n    .by = genre # variável a ser agrupada\n  )\n\nAlém dos agrupamentos feitos aqui, é possível agrupar para mais de uma variável, para isso, basta especificar o vetor de variáveis que queremos que sejam agrupados dentro do c(). Vejamos um exemplo onde agrupamos tanto por gênero do filme quanto sua classificação indicativa:\n\nfilmes |&gt; \n  group_by(genre, mpaa_rating) |&gt; \n  summarise(\n    receita = sum(worldwide_gross)\n  )\n\nOu como visto anteriormente, sem utilizar a função group_by() e passando os argumentos diretamente dentro da função summarise() no argumento .by:\n\nfilmes |&gt; \n  summarise(\n    receita = sum(worldwide_gross), \n    .by = c(genre, mpaa_rating) # variável a ser agrupada\n  )\n\nImportante lembrar que a ordem na qual passamos as variáveis a serem agrupadas altera a disposição final do resultado mostrado, embora os valores sejam os mesmos. Por exemplo, com nossos dados anteriores, invertendo os agrupamentos:\n\nfilmes |&gt; \n  summarise(\n    receita = sum(worldwide_gross), \n    .by = c(mpaa_rating, genre) # variável a ser agrupada\n  )\n\nApós termos visto o processo de contar e resumir informações de nossas variáveis, vamos na próxima sessão mostrar como é possível realizar mais cálculos com nossa base de dados por meio da função mutate(), outra função que é muito utilizada em qualquer análise que façamos com dados dentro do R.",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Construindo Medidas Resumo</span>"
    ]
  },
  {
    "objectID": "capitulos/05.adicionando_colunas.html",
    "href": "capitulos/05.adicionando_colunas.html",
    "title": "5  Adicionando Colunas",
    "section": "",
    "text": "5.1 Conhecendo a sintaxe\nVamos aprender como construir uma variável em nosso banco de dados a partir de um exemplo simples, apenas para aprendermos o funcionamento da função mutate(). Para isso, na próxima linha de código vamos primeiro criar uma amostra de valores a partir dos dez filmes com maior faturamento no mercado doméstico, o qual vamos chamar de maiores_bilheterias:\nmaiores_bilheterias &lt;- \n  filmes |&gt; \n  slice_max(domestic_gross, n = 10) |&gt; \n  select(movie, domestic_gross, worldwide_gross, production_budget)\n10 maiores bilheterias domésticas\n\n\nmovie\ndomestic_gross\nworldwide_gross\nproduction_budget\n\n\n\n\nStar Wars Ep. I: The Phantom Menace\n474544677\n1027044677\n115000000\n\n\nStar Wars Ep. IV: A New Hope\n460998007\n786598007\n11000000\n\n\nShrek 2\n441226247\n937008132\n70000000\n\n\nET: The Extra-Terrestrial\n435110554\n792965326\n10500000\n\n\nThe Hunger Games: Catching Fire\n424668047\n864868047\n130000000\n\n\nThe Lion King\n421785283\n986332275\n79300000\n\n\nJurassic World: Fallen Kingdom\n416769345\n1304866322\n170000000\n\n\nWonder Woman\n412563408\n821133378\n150000000\n\n\nJumanji: Welcome to the Jungle\n404508916\n961758540\n90000000\n\n\nSpider-Man\n403706375\n821706375\n139000000\nAgora que já temos uma base mais reduzida para trabalharmos, podemos então partir para usar nossa função mutate(). Como comentado, essa função serve para nos ajudar a construir novas colunas, ou seja, adicionar variáveis a nossa base de dados. Digamos que essa nova variável que gostaríamos de acrescentar fosse a receita total de cada um dos 10 filmes, ou seja, nossa nova variável deveria ser a soma das receitas com bilheterias doméstica e estrangeira. Com a mutate(), seu código deveria ser o seguinte:\nmaiores_bilheterias |&gt; \n  mutate(\n    # construindo nossa nova variável receita_total\n    receita_total = domestic_gross + worldwide_gross\n  )\nPelo código acima, podemos perceber que agora temos uma quinta variável em nosso banco de dados, receita_total, que foi criada com a função mutate() pela soma das variáveis domestic_gross e worldwide_gross. Em geral, a sintaxe da função mutate() será sempre essa:\nPodemos construir quantas variáveis necessitamos dentro da mutate(), por exemplo, agora que sabemos a receita total, podemos calcular o lucro total de cada um desses filmes. Para isso, basta subtraírmos da receita total seus custos de produção, dados pela variável production_budget, como mostra o próximo código.\nmaiores_bilheterias |&gt; \n  mutate(\n    # construindo nossa nova variável receita_total\n    receita_total = domestic_gross + worldwide_gross, \n    # lucro de cada um dos filmes\n    lucro = receita_total - production_budget\n  )\nUm detalhe que precisamos observar do código acima é fundamental: cada nova variável a ser construída, deverá ser separada por vírgulas dentro da mutate(), caso isso não seja feito, teremos uma mensagem de erro.\nPara uma melhor visualização, vamos mostrar o mesmo resultado apenas com o filme e seu respectivo lucro:\nmaiores_bilheterias |&gt; \n  mutate(\n    # construindo nossa nova variável receita_total\n    receita_total = domestic_gross + worldwide_gross, \n    # lucro de cada um dos filmes\n    lucro = receita_total - production_budget\n  ) |&gt; \n  select(filme = movie, lucro)\nUm detalhe apareceu nessa última representação dos dados, embora a amostra de filmes tivesse sido obtida por meio da seleção das 10 maiores receitas domésticas, e esses filmes viessem ordenados dessa maneira, agora que sabemos o valor do lucro para cada um deles, não temos mais a tabela em sua ordem correta. Isso não é problema porque como sabemos, podemos utilizar a função arrange() para ordenar os dados, como é mostrado a seguir.\nmaiores_bilheterias |&gt; \n  mutate(\n    # construindo nossa nova variável receita_total\n    receita_total = domestic_gross + worldwide_gross, \n    # lucro de cada um dos filmes\n    lucro = receita_total - production_budget\n  ) |&gt; \n  select(filme = movie, lucro) |&gt; \n  arrange(desc(lucro))",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adicionando Colunas</span>"
    ]
  },
  {
    "objectID": "capitulos/05.adicionando_colunas.html#conhecendo-a-sintaxe",
    "href": "capitulos/05.adicionando_colunas.html#conhecendo-a-sintaxe",
    "title": "5  Adicionando Colunas",
    "section": "",
    "text": "Chamamos a função mutate();\nDentro dela construímos o cálculo, primeiro dizendo um nome para a variável a ser criada, segundo indicando como ela será criada (com quais operações matemáticas, por exemplo),",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adicionando Colunas</span>"
    ]
  },
  {
    "objectID": "capitulos/05.adicionando_colunas.html#outros-exemplos-de-cálculos",
    "href": "capitulos/05.adicionando_colunas.html#outros-exemplos-de-cálculos",
    "title": "5  Adicionando Colunas",
    "section": "5.2 Outros exemplos de cálculos",
    "text": "5.2 Outros exemplos de cálculos\nConhecendo o funcionamento da função mutate() podemos realizar mais alguns exemplos para fixar melhor seu uso. Digamos que gostaríamos de deixar os valores dos lucros em milhões de dólares, e não como é mostrado na tabela. Poderíamos apenas aplicar uma nova escala a esses valores por meio da multiplicação por \\(\\frac{1}{1000000}\\) dentro da função mutate() como é visto na sequência.\n\nmaiores_bilheterias |&gt; \n  mutate(\n    # construindo nossa nova variável receita_total\n    receita_total = domestic_gross + worldwide_gross, \n    # lucro de cada um dos filmes\n    lucro = receita_total - production_budget, \n    # transformando os valores\n    lucro_1 = lucro*(1/1000000)\n  ) |&gt; \n  select(filme = movie, lucro, lucro_1) |&gt; \n  arrange(desc(lucro))\n\nAlgumas considerações sobre o código anterior. A primeira delas é a de que fiz a representação de duas variáveis para a mesma informação, lucro e lucro_1, apenas para melhor entendimento do que estava sendo feito e para deixar evidente que os valores mostrados em milhões de dólares são mais interessantes de visualizar.\nA segunda observação é quanto ao código, no geral, você não precisa utilizar uma linha de código adicional, dado que você poderia fazer essa mudança na escala dos dados já no momento que calculou o lucro, como mostrado no código abaixo:\n\nmaiores_bilheterias |&gt; \n  mutate(\n    # construindo nossa nova variável receita_total\n    receita_total = domestic_gross + worldwide_gross, \n    # lucro de cada um dos filmes\n    lucro = (receita_total - production_budget)*1/1000000\n  ) |&gt; \n  select(filme = movie, lucro) |&gt; \n  arrange(desc(lucro))\n\nOutra função que vamos utilizar com certa frequência é round() que ajuda no processo de arredondamento dos dados. Por exemplo, no código anterior vimos que os valores ficaram com casas decimais. Para eliminar isso podemos utilizar essa função round() na variável lucro, como mostra o código seguinte:\n\nmaiores_bilheterias |&gt; \n  mutate(\n    # construindo nossa nova variável receita_total\n    receita_total = domestic_gross + worldwide_gross, \n    # lucro de cada um dos filmes\n    lucro = (receita_total - production_budget)*1/1000000, \n    lucro_1 = round(lucro)\n  ) |&gt; \n  select(filme = movie, lucro, lucro_1) |&gt; \n  arrange(desc(lucro))\n\nNovamente aqui, apenas para observarmos a diferença, construi a variável duas vezes. A função round() possui um argumento que indica o número de casas decimais, digits =, cujo valor padrão é zero, para não ter casas decimais. O código mais limpo seria algo como:\n\nmaiores_bilheterias |&gt; \n  mutate(\n    # construindo nossa nova variável receita_total\n    receita_total = domestic_gross + worldwide_gross, \n    # lucro de cada um dos filmes\n    lucro = round((receita_total - production_budget)*1/1000000), \n  ) |&gt; \n  select(filme = movie, lucro) |&gt; \n  arrange(desc(lucro))\n\nVoltando a nossa tabela original de filmes sabemos que existe uma variável que indica o gênero dos filmes. Vimos que a função count() pode nos fornecer informações sobre quantos filmes estão em cada categoria, como mostrado no seguinte código:\n\nfilmes |&gt; \n  select(movie, genre) |&gt; \n  count(genre, sort = T)\n\nPoderia ser do nosso interesse calcular além da frequência absoluta, a frequência relativa dos valores da variável genre. Para isso, precisamos criar uma outra coluna em nosso banco de dados com a função mutate(). Vejamos como ficaria o código e voltamos para analisar o que foi feito:\n\nfilmes |&gt; \n  select(movie, genre) |&gt; \n  count(genre, sort = T) |&gt; \n  mutate(\n    # construindo a frequencia relativa\n    fr_relativa = n/3401 # numero total de filmes\n  )\n\nNo código acima, pegamos cada valor que indicava a quantidade de filmes para uma categoria, e dividimos pelo total de filmes em nossa base, 3401 para chegar até a participação relativa do gênero na base. Contudo, o modo como foi feito acima não é o mais adequado, porque caso nossa base de dados tivesse mudado, por exemplo, por meio do acrescimo de filmes, teriamos que modificar manualmente nosso código, e a ideia de utilizar uma linguagem de programação é deixar essas tarefas o mais automatizadas possíveis.\nComo forma de corrigir esse problema podemos refazer o código acima com uma pequena modificação:\n\nfilmes |&gt; \n  select(movie, genre) |&gt; \n  count(genre, sort = T) |&gt; \n  mutate(\n    # construindo a frequencia relativa\n    fr_relativa = n/sum(n) \n  )\n\nA divisão por sum(n) calcula o total de filmes que estão na coluna anterior n. Assim, não precisamos nos preocupar em saber qual é o total de filmes, pois essa função calcula e o valor calculado será utilizado como o denominador em cada uma das frequências relativas.\nPoderíamos ainda modificar o exemplo anterior para mostrar esse valor em percentual, para isso, bastaria multiplicar por 100 o cálculo feito antes:\n\nfilmes |&gt; \n  select(movie, genre) |&gt; \n  count(genre, sort = T) |&gt; \n  mutate(\n    # construindo a frequencia relativa\n    fr_relativa = round((n/sum(n))*100, digits = 2)\n  )\n\nEmbora não faça sentido para os dados acima, poderíamos calcular a frequencia acumulada também, algo que é muito comum em determinadas aplicações. Isso é feito, como mostra o código seguinte, utilizando a função cumsum().\n\nfilmes |&gt; \n  select(movie, genre) |&gt; \n  count(genre, sort = T) |&gt; \n  mutate(\n    # construindo a frequencia relativa\n    fr_relativa = round((n/sum(n))*100, digits = 2), \n    # frequencia absoluta acumulada\n    f_acumulada = cumsum(n)\n  )\n\nE podemos também calcular a frequencia relativa acumulada1:\n1 O último valor da frequência relativa acumulada percentual não fechou em 100% devido aos arredondamentos. Caso na função round() definirmos o parâmetro digits = 0, o valor fecha nos 100%.\nfilmes |&gt; \n  select(movie, genre) |&gt; \n  count(genre, sort = T) |&gt; \n  mutate(\n    # construindo a frequencia relativa\n    fr_relativa = round((n/sum(n))*100, digits = 2), \n    # frequencia absoluta acumulada\n    f_acumulada = cumsum(n), \n    # frequencia relativa acumulada\n    fr_acumulada = cumsum(fr_relativa)\n  )\n\nCom a função mutate() podemos inserir valores constantes como por exemplo:\n\nfilmes |&gt; \n  select(movie, domestic_gross) |&gt; \n  slice_max(domestic_gross, n = 10) |&gt; \n  mutate(\n    # adicionando um valor qualquer\n    variavel_3 = 1, \n    # adicionando um texto\n    variavel_4 = \"Texto aqui!!\"  \n  )\n\nNaturalmente o que fizemos antes não faz sentido nesse contexto, mas apenas para lembrar que a função mutate() constrói colunas, e o tipo de coluna que precisamos construir pode ser muito diferente de aplicação para aplicação, mas que podem ser cobertos dentro do mutate(). Uma ultima advertência, no momento que estivermos dando nome as variáveis a serem criadas, as mesmas recomendações anteriormente citadas são válidas aqui.\nNa próxima sessão vamos poder presenciar o uso da função mutate() mais uma vez, mas agora aplicada a um outro contexto, no qual vamos analisar uma coluna com condições do tipo: Se o valor da variável for tal, então realizamos esse cálculo!",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adicionando Colunas</span>"
    ]
  },
  {
    "objectID": "capitulos/05.adicionando_colunas.html#função-if_else-e-case_when",
    "href": "capitulos/05.adicionando_colunas.html#função-if_else-e-case_when",
    "title": "5  Adicionando Colunas",
    "section": "5.3 Função if_else() e case_when()",
    "text": "5.3 Função if_else() e case_when()\nUm dos usos mais comuns da função mutate() é em conjunto com a função if_else(). Para entender essa aplicação, digamos que em nossa base de dados, queremos retornar uma nova coluna na qual os filmes estejam separados apenas entre comédia e demais gêneros. Da maneira como estão os valores da variável, genre isso não seria possível, porque os dados possuem cinco gêneros, como mostrado no código abaixo:\n\nfilmes |&gt; \n  distinct(genre)\n\nPodemos utilizar a função if_else() para modificar essa variável e colocar apenas esses dois rótulos, comédia e demais gêneros. Para isso, vamos fazer uso dessa função dentro da função mutate() como indicado no código seguinte:\n\nfilmes |&gt; \n  select(movie, genre) |&gt; \n  mutate(\n    novo_genero = if_else(\n      # condição lógica a ser analisada\n      genre == \"Comedy\",\n      # valor se verdadeiro\n      \"Comédia\", \n      # valor se falso\n      \"Demais generos\"\n    )\n  )\n\nNo código acima, dentro da função if_else() o que temos é uma condição lógica sendo analisada, e os valores que queremos que ela retorne quando tal condição for verdadeira e quando for falsa. Por exemplo, genre == \"Comedy\" faz com que a função if_else() olhe cada valor da variável genre e observe quando o valor é igual a Comedy. Quando ele identifica o valor igual a condição, ele associa o valor verdadeiro definido, “Comédia”, mas se o gênero do filme for outro, vai associar o rótulo “Demais generos”.\nAlém disso, como estamos passando esse código dentro da função mutate(), ela vai criar uma nova coluna em nosso banco de dados, no caso, pedimos para dar o nome para essa nova coluna como novo_genero.\nAqui uma observação, poderíamos ter dado o mesmo nome da coluna genre, contudo, se isso fosse feito teríamos escrito os valores sobre a variável original, como mostrado no código seguinte:\n\nfilmes |&gt; \n  select(movie, genre) |&gt; \n  mutate(\n    genre = if_else(\n      # condição lógica a ser analisada\n      genre == \"Comedy\",\n      # valor se verdadeiro\n      \"Comédia\", \n      # valor se falso\n      \"Demais generos\"\n    )\n  )\n\nA função if_else() possui a limitação de conseguir analisar apenas as duas condições por vez, se o valor for verdadeiro então ela associa algum valor definido, mas se for falso, associa outro. Contudo, existe a função case_when() na qual podemos analisar mais condições.\nDigamos que queremos classificar as distribuidoras segundo a quantidade de filmes, para isso, a partir do código abaixo podemos utilizar a função case_when() para fazer essas classificações, por exemplo, associando “Top 200+” para as distribruidoras com mais de 200 filmes distribuidos; “Top 100+” para as distribuidoras com mais de 100 filmes, mas menos de 200 filmes distribuidos; “Top 50+” para mais de 50 filmes distribuidos e “Demais distribuidoras”.\n\nfilmes |&gt; \n  count(distributor, sort = T) |&gt; \n  mutate(\n    classificacao = case_when(\n      n &gt;= 200 ~ \"Top 200+\", \n      n &gt;= 100 ~ \"Top 100+\", \n      n &gt;= 50 ~ \"Top 50+\", \n      .default = \"Demais distribuidoras\"\n    )\n  ) \n\nA sintaxe dessa função é apenas indicar cada uma das nossas condições lógicas que devem ser atendidas, sendo que se o valor a ser associado a cada condição deve ser indicado depois do símbolo ~; Além disso, no exemplo acima na última opção não foi preciso indicar algo como n &gt;= 0 ~ \"Demais distribuidoras\", bastou apenas utilizar a opção .default que serve para indicar qual valor deve ser associado se nenhuma das condições anteriores foi atendida.\nNaturalmente, muitas outras possibilidade de uso dessas duas funções podem ser pensadas, contudo, para um primeiro momento o que você deve fixar é a maneira como devemos passar os valores que serão associados a cada um dos testes lógicos que as funções estão avaliando.\nIsso fecha a primeira parte de nosso material, na próxima parte vamos aprender a como fazer importação de diferentes tipos de arquivos, bem como mais algumas coisas úteis em nosso início de jornada na linguagem R.",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adicionando Colunas</span>"
    ]
  },
  {
    "objectID": "capitulos/06.importando_dados.html",
    "href": "capitulos/06.importando_dados.html",
    "title": "6  Importando Dados do PC",
    "section": "",
    "text": "6.1 Importando um arquivo .csv\nNossa primeira base de dados que vinhamos trabalhando até aqui, filmes, foi importada para dentro do R por meio da função read_csv(). Como a própria função deixa bastante intuitivo, ela é utilizada para fazer a importação de arquivos cuja extensão seja .csv, como era o caso do nossa arquivo. Esse arquivo de dados não estava originalmente em nossa máquina, em alguma pasta, mas estava em um link que informamos dentro da própria função, como é possível recordar pelo código abaixo.\n# baixando nossa primeira base de dados\nfilmes &lt;- read_csv(\"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2018/2018-10-23/movie_profit.csv\")\nNa grande maior de nossos trabalhos com dados, o comum é que tenhamos realizado o download da base para nosso computador primeiro, para alguma pasta de trabalho que definimos que reunirá as informações do projeto no qual estamos trabalhando. Quando esse é caso, pouco vai mudar em nossa maneira de utilizar a função que vai importar os dados, a única diferença que teremos será ao invés de indicar uma URL, como foi o caso até aqui, vamos especificar o endereço da pasta de trabalho onde está nosso arquivo.\nDigamos que nosso arquivo contendo os dados esteja em uma pasta chamada meus_dados no nosso computador, com o seguinte nome movie_profit.csv1, ou seja, é um arquivo que está na extensão .csv. Quando esse é o caso, existem duas funções possíveis de serem utilizadas, read_csv() e read_csv2(), cuja diferença está no separador utilizado no arquivo.\nQuando nossos arquivos são de textos, como são os arquivos .csv, o mais comum é que eles separem cada variável na base por meio de uma “,”, mas em outras situações, como no Brasil, o comum é também existirem arquivos separado por “;”. Quando estamos diante de um arquivo que tem seus valores separados por vírgula, devemos utilizar a função read_csv(), mas se o arquivo utiliza o separador ponto-vírgula, utilizamos read_csv2().\nPara que o arquivo seja importado para o RStudio vamos precisar dentro da função read_csv() indicar o caminho completo da pasta onde o arquivo está localizado2. No meu computador, o caminho completo quando copiamos fica como: \"C:\\Users\\Felipe\\Documents\\meus_dados\\movie_profit.csv\". Adicionando na função read_csv() o caminho, teríamos o seguinte código:\ndados &lt;- read_csv(\"C:\\Users\\Felipe\\Documents\\meus_dados\\movie_profit.csv\")\nContudo, se esse código for executado resultará em um erro! Isso é o resultado das barras que estão sendo utilizadas no caminho do diretório, \"\\\". Para contornar esse problema temos duas opções: utilizamos barras duplas \"\\\\\"; ou utilizamos a barra invertida \"/\". Vejamos os códigos:\n# Primeira forma\ndados &lt;- read_csv(\"C:\\\\Users\\\\Felipe\\\\Documents\\\\meus_dados\\\\movie_profit.csv\")\n# Segunda forma\ndados_1 &lt;- read_csv(\"C:/Users/Felipe/Documents/meus_dados/movie_profit.csv\")\nAs funções read_csv() vão possuir alguns argumentos adicionais, como por exemplo, a possibilidade de selecinarmos apenas determinadas colunas de nossa base de dados, alterarmos os nomes, modificar seus tipos. Além disso, a base que importamos não apresentava necessidade de realizar qualquer tratamento prévio, o que na prática não vai acontecer. Nessas situações, vai exigir habilidade para trabalhar com esses argumentos adicionais, o que foge ao objetivo do workshop.",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Importando Dados do PC</span>"
    ]
  },
  {
    "objectID": "capitulos/06.importando_dados.html#importando-um-arquivo-.csv",
    "href": "capitulos/06.importando_dados.html#importando-um-arquivo-.csv",
    "title": "6  Importando Dados do PC",
    "section": "",
    "text": "1 Baixe aqui o arquivo!\n\n\n2 Uma das maneiras mais simples de fazer isso é clicar com o botão direito do mouse sobre o arquivo, verificar a lista de opções que será mostrada e clicar em “copiar como caminho”.",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Importando Dados do PC</span>"
    ]
  },
  {
    "objectID": "capitulos/06.importando_dados.html#importando-planilhas-de-excel",
    "href": "capitulos/06.importando_dados.html#importando-planilhas-de-excel",
    "title": "6  Importando Dados do PC",
    "section": "6.2 Importando Planilhas de Excel",
    "text": "6.2 Importando Planilhas de Excel\nQuando temos planilhas, como as tradicionais planilhas de excel, elas também poderão ser carregadas para o R, contudo, vamos precisar de um outro pacote para fazer isso, o pacote readxl. Vamos trabalhar como uma mesma versão de nossa base de dados, só que agora a mesma vai estar em uma planilha de excel3, além disso, vamos precisar fazer primeiro a importação do pacote readxl4.\n3 Baixe aqui o arquivo!\n4 install.packages(\"readxl\")Depois de termos carregado nosso pacote readxl, vamos utilizar a função read_xlsx() para ler arquivos em excel cuja extensão seja .xlsx seguindo as mesmas recomendações do caso onde nosso arquivo era .csv, como podemos ver pelo código abaixo:\n\nlibrary(readxl) # carregando nosso pacote\n# Segunda forma\ndados_1 &lt;- read_xlsx(\"C:/Users/Felipe/Documents/meus_dados/movie_profit.xlsx\")\n\nEm alguns casos será interessante utilizar a função read_xls() que faz a leitura de arquivos em excel de versões mais antigas. Além disso, as funções do pacote readxl também possuem diversos argumentos para serem utilizados, principalmente em arquivos em excel que não estão bem organizados como foi o caso do exemplo.",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Importando Dados do PC</span>"
    ]
  },
  {
    "objectID": "capitulos/06.importando_dados.html#função-tibble",
    "href": "capitulos/06.importando_dados.html#função-tibble",
    "title": "6  Importando Dados do PC",
    "section": "6.3 Função tibble()",
    "text": "6.3 Função tibble()\nAté aqui trabalhamos com base de dados que foram importadas, sejam elas vindas de uma URL ou do nosso computador. Em muitas situações pode ser necessário construir pequenas bases de dados, como por exemplo, alguma base de dado que esteja em algum livro de estatística. Nessas situações, podemos contar com a função tibble().\nCada variável dessa base de dados será construida com o uso da função c(), da seguinte maneira: primeiro definiremos o nome de nossa variável, por exemplo variavel_1, depois inserimos seus valores dentro da função c(). Vejamos um exemplo:\n\ntibble(variavel_1 = c(20, 15, 40, 18, 6))\n\n# A tibble: 5 × 1\n  variavel_1\n       &lt;dbl&gt;\n1         20\n2         15\n3         40\n4         18\n5          6\n\n\nPodemos criar quantas variáveis forem de nosso interesse:\n\nmeus_dados &lt;- tibble(\n  nome = c(\"João\", \"Maria\", \"Carlos\"), \n  nota = c(0.5, 4, 8)\n)\n\nmeus_dados\n\n# A tibble: 3 × 2\n  nome    nota\n  &lt;chr&gt;  &lt;dbl&gt;\n1 João     0.5\n2 Maria    4  \n3 Carlos   8  \n\n\nCertamente essas pequenas demostrações não esgotam as possibilidades de uso do R para importação de dados, mas servem como um primeiro passo. Existem muitos outros pacotes que trabalham com os mais variados tipos de dados, de acordo com as necessidades de cada pesquisador.",
    "crumbs": [
      "PARTE 2",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Importando Dados do PC</span>"
    ]
  }
]